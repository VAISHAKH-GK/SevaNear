// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: services.sql

package generated

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createService = `-- name: CreateService :one
INSERT INTO services (
    hospital_id,
    service_type_id,
    name,
    description,
    timings,
    eligibility,
    contact,
    latitude,
    longitude
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9
)
RETURNING id, hospital_id, service_type_id, latitude, longitude, name, description, timings, eligibility, contact, created_at
`

type CreateServiceParams struct {
	HospitalID    int32   `json:"hospital_id"`
	ServiceTypeID int32   `json:"service_type_id"`
	Name          string  `json:"name"`
	Description   *string `json:"description"`
	Timings       *string `json:"timings"`
	Eligibility   *string `json:"eligibility"`
	Contact       *string `json:"contact"`
	Latitude      float64 `json:"latitude"`
	Longitude     float64 `json:"longitude"`
}

func (q *Queries) CreateService(ctx context.Context, arg CreateServiceParams) (Service, error) {
	row := q.db.QueryRow(ctx, createService,
		arg.HospitalID,
		arg.ServiceTypeID,
		arg.Name,
		arg.Description,
		arg.Timings,
		arg.Eligibility,
		arg.Contact,
		arg.Latitude,
		arg.Longitude,
	)
	var i Service
	err := row.Scan(
		&i.ID,
		&i.HospitalID,
		&i.ServiceTypeID,
		&i.Latitude,
		&i.Longitude,
		&i.Name,
		&i.Description,
		&i.Timings,
		&i.Eligibility,
		&i.Contact,
		&i.CreatedAt,
	)
	return i, err
}

const getAllServices = `-- name: GetAllServices :many
SELECT
    s.id,
    s.name,
    s.description,
    s.timings,
    s.eligibility,
    s.contact,
    s.latitude,
    s.longitude,
    s.created_at,

    h.id AS hospital_id,
    h.name AS hospital_name,

    st.id AS service_type_id,
    st.name AS service_type
FROM services s
JOIN hospitals h ON s.hospital_id = h.id
JOIN service_types st ON s.service_type_id = st.id
ORDER BY s.created_at DESC
`

type GetAllServicesRow struct {
	ID            int32            `json:"id"`
	Name          string           `json:"name"`
	Description   *string          `json:"description"`
	Timings       *string          `json:"timings"`
	Eligibility   *string          `json:"eligibility"`
	Contact       *string          `json:"contact"`
	Latitude      float64          `json:"latitude"`
	Longitude     float64          `json:"longitude"`
	CreatedAt     pgtype.Timestamp `json:"created_at"`
	HospitalID    int32            `json:"hospital_id"`
	HospitalName  string           `json:"hospital_name"`
	ServiceTypeID int32            `json:"service_type_id"`
	ServiceType   string           `json:"service_type"`
}

func (q *Queries) GetAllServices(ctx context.Context) ([]GetAllServicesRow, error) {
	rows, err := q.db.Query(ctx, getAllServices)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllServicesRow
	for rows.Next() {
		var i GetAllServicesRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Timings,
			&i.Eligibility,
			&i.Contact,
			&i.Latitude,
			&i.Longitude,
			&i.CreatedAt,
			&i.HospitalID,
			&i.HospitalName,
			&i.ServiceTypeID,
			&i.ServiceType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getServiceByID = `-- name: GetServiceByID :one
SELECT
    s.id,
    s.name,
    s.description,
    s.timings,
    s.eligibility,
    s.contact,
    s.latitude,
    s.longitude,
    s.created_at,

    h.id AS hospital_id,
    h.name AS hospital_name,

    st.id AS service_type_id,
    st.name AS service_type
FROM services s
JOIN hospitals h ON s.hospital_id = h.id
JOIN service_types st ON s.service_type_id = st.id
WHERE s.id = $1
`

type GetServiceByIDRow struct {
	ID            int32            `json:"id"`
	Name          string           `json:"name"`
	Description   *string          `json:"description"`
	Timings       *string          `json:"timings"`
	Eligibility   *string          `json:"eligibility"`
	Contact       *string          `json:"contact"`
	Latitude      float64          `json:"latitude"`
	Longitude     float64          `json:"longitude"`
	CreatedAt     pgtype.Timestamp `json:"created_at"`
	HospitalID    int32            `json:"hospital_id"`
	HospitalName  string           `json:"hospital_name"`
	ServiceTypeID int32            `json:"service_type_id"`
	ServiceType   string           `json:"service_type"`
}

func (q *Queries) GetServiceByID(ctx context.Context, id int32) (GetServiceByIDRow, error) {
	row := q.db.QueryRow(ctx, getServiceByID, id)
	var i GetServiceByIDRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Timings,
		&i.Eligibility,
		&i.Contact,
		&i.Latitude,
		&i.Longitude,
		&i.CreatedAt,
		&i.HospitalID,
		&i.HospitalName,
		&i.ServiceTypeID,
		&i.ServiceType,
	)
	return i, err
}

const getServicesByHospitalID = `-- name: GetServicesByHospitalID :many
SELECT id, hospital_id, service_type_id, latitude, longitude, name, description, timings, eligibility, contact, created_at FROM services
WHERE hospital_id = $1
ORDER BY created_at DESC
`

func (q *Queries) GetServicesByHospitalID(ctx context.Context, hospitalID int32) ([]Service, error) {
	rows, err := q.db.Query(ctx, getServicesByHospitalID, hospitalID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Service
	for rows.Next() {
		var i Service
		if err := rows.Scan(
			&i.ID,
			&i.HospitalID,
			&i.ServiceTypeID,
			&i.Latitude,
			&i.Longitude,
			&i.Name,
			&i.Description,
			&i.Timings,
			&i.Eligibility,
			&i.Contact,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getServicesByServiceTypeID = `-- name: GetServicesByServiceTypeID :many
SELECT id, hospital_id, service_type_id, latitude, longitude, name, description, timings, eligibility, contact, created_at FROM services
WHERE service_type_id = $1
ORDER BY created_at DESC
`

func (q *Queries) GetServicesByServiceTypeID(ctx context.Context, serviceTypeID int32) ([]Service, error) {
	rows, err := q.db.Query(ctx, getServicesByServiceTypeID, serviceTypeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Service
	for rows.Next() {
		var i Service
		if err := rows.Scan(
			&i.ID,
			&i.HospitalID,
			&i.ServiceTypeID,
			&i.Latitude,
			&i.Longitude,
			&i.Name,
			&i.Description,
			&i.Timings,
			&i.Eligibility,
			&i.Contact,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getServicesNearLocation = `-- name: GetServicesNearLocation :many
SELECT
    s.id, s.hospital_id, s.service_type_id, s.latitude, s.longitude, s.name, s.description, s.timings, s.eligibility, s.contact, s.created_at,
    (
        6371 * acos(
            cos(radians($1)) * cos(radians(s.latitude)) *
            cos(radians(s.longitude) - radians($2)) +
            sin(radians($1)) * sin(radians(s.latitude))
        )
    ) AS distance_km
FROM services s
HAVING (
    6371 * acos(
        cos(radians($1)) * cos(radians(s.latitude)) *
        cos(radians(s.longitude) - radians($2)) +
        sin(radians($1)) * sin(radians(s.latitude))
    )
) < $3
ORDER BY distance_km
`

type GetServicesNearLocationParams struct {
	Radians   float64 `json:"radians"`
	Radians_2 float64 `json:"radians_2"`
	Latitude  float64 `json:"latitude"`
}

type GetServicesNearLocationRow struct {
	ID            int32            `json:"id"`
	HospitalID    int32            `json:"hospital_id"`
	ServiceTypeID int32            `json:"service_type_id"`
	Latitude      float64          `json:"latitude"`
	Longitude     float64          `json:"longitude"`
	Name          string           `json:"name"`
	Description   *string          `json:"description"`
	Timings       *string          `json:"timings"`
	Eligibility   *string          `json:"eligibility"`
	Contact       *string          `json:"contact"`
	CreatedAt     pgtype.Timestamp `json:"created_at"`
	DistanceKm    int32            `json:"distance_km"`
}

func (q *Queries) GetServicesNearLocation(ctx context.Context, arg GetServicesNearLocationParams) ([]GetServicesNearLocationRow, error) {
	rows, err := q.db.Query(ctx, getServicesNearLocation, arg.Radians, arg.Radians_2, arg.Latitude)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetServicesNearLocationRow
	for rows.Next() {
		var i GetServicesNearLocationRow
		if err := rows.Scan(
			&i.ID,
			&i.HospitalID,
			&i.ServiceTypeID,
			&i.Latitude,
			&i.Longitude,
			&i.Name,
			&i.Description,
			&i.Timings,
			&i.Eligibility,
			&i.Contact,
			&i.CreatedAt,
			&i.DistanceKm,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
